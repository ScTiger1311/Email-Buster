class Play extends Phaser.Scene {
    constructor() {
        super("Play");
    }

    //if you plan on using assets, you can load them here to load it at the start of the scene. Or, you can load them on the fly. https://rexrainbow.github.io/phaser3-rex-notes/docs/site/loader/
    preload() {
        this.load.atlas("clearbutton_red", "./assets/spritesheets/clearbutton_red.png", "./assets/spritesheets/clearbutton_red.json"); //this one is used for testing/debugging purposes
        this.load.atlas("clearbutton", "./assets/spritesheets/clearbutton.png", "./assets/spritesheets/clearbutton.json"); //this one is used as an invisible hitbox
        this.load.atlas("clearbutton_darken", "./assets/spritesheets/clearbutton_darken.png", "./assets/spritesheets/clearbutton_darken.json"); //this one is used as an invisible hitbox
        this.load.atlas("button", "./assets/spritesheets/button_spritesheet.png", "./assets/spritesheets/button_spritesheet.json"); //this one is used as an actual button
        this.load.image("MailBG", "./assets/single_sprites/MailBG.png"); //used as a background for the game
        this.load.image("Report_Menu", "./assets/single_sprites/Report_Menu.png"); //used for reporting the email as fishy
    }

    //runs once, after preload, just as the scene starts
    create() {
        console.log("entered the Play.js scene");

        //all the variables you might want to edit to tweak the difficulty of the game
        this.mailQueueLength = 10; //the length of the mail queue. Must be greater than fakeMailMinimumAmount
        this.fakeMailMinimumAmount = 2; //the minimum amount of fake mail in the queue. If the game generates less than this amount, automatically replaces random real mail with fake mail
        this.fakeMaxVal = 0; //determines the % chance of a fake mail

        this.unusedMailReal = //stores all the real mail objects (see Mail.js for a description of the data type)
        [
            new Mail(this, "./assets/single_sprites/Mail1_Real.png", true,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Real.png", true,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Real.png", true,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Real.png", true,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Real.png", true,  true, true, false, false),
        ];
        this.unusedMailFake = //stores all the fake mail objects
        [
            new Mail(this, "./assets/single_sprites/Mail1_Fake.png", false,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Fake.png", false,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Fake.png", false,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Fake.png", false,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Fake.png", false,  true, true, false, false),
            new Mail(this, "./assets/single_sprites/Mail1_Fake.png", false,  true, true, false, false),
            
        ];
        
        this.mailSprite = 0; //placeholder to give this a value that exists, but isn't a gameobject.
        this.nextButton = 0;
        this.bgSprite = this.add.sprite(0,0, "MailBG").setOrigin(0,0);
        this.usedMailReal = []; //stores all of the used real mail in the current game session, so that repeat mail will not occur
        this.usedMailFake = []; //stores all of the used fake mail in the current game session, so that repeat mail will not occur
        this.emailQueue = this.generateMailQueue(this.mailQueueLength, this.fakeMailMinimumAmount); //the queue of all the mail. needs to be generated by the function generateMailQueue()
        this.showNewMail(this.emailQueue);//loads the initial email
        this.reportButton = new Button(this, "clearbutton_darken", 765, 2, this.showReportMenu, [])
        this.reportButton.setHeight(59);
        this.reportButton.setWidth(230);
        this.nextButton = new Button(this, "button", 1000, 700, this.nextMailInQueue, [this.emailQueue]);
    }

    update(time, delta) {
        let deltaMultiplier = (delta / 16.66667); //for refresh rate indepence
    }

    generateMailQueue(queueLength, fakeMailMin)
    {
        let arrayToReturn = [];
        let numFakeMails = 0;

        if(queueLength < fakeMailMin) //check to make sure variables are set properly
        {
            console.log("ERROR in Play.js, generateMailQueue(): You set queueLength less than fakeMailMin");
            this.destroy();
        }
        for(let i = 0; i < queueLength; i++) //generates an array of a length, populated with 0=fake, 1=real
        {
            let randNum = Math.random() * 100;
            if(randNum <= this.fakeMaxVal) //generates a placeholder fake slot
            {
                arrayToReturn[i] = 0;
                numFakeMails++;
                
            }
            else //generates a placeholder real slot
            {
                arrayToReturn[i] = 1;
            }
        }
        if(numFakeMails < fakeMailMin) //generates fake mail placeholders in random slots, up to the value of fakeMailMin
        {
            for(let i = 0; i < fakeMailMin - numFakeMails; i++)
            {
                let randNum = Math.floor(Math.random() * queueLength);
                if(arrayToReturn[randNum] == 1) //if the index of random number generated is already a real mail, make it fake
                {
                    arrayToReturn[randNum] = 0;
                }
                else //if it isn't, loop through the array after the random number until you find one that is.
                {
                    for(let j = 1; j < fakeMailMin + 1; i++)
                    {
                        if(randNum + j <= queueLength)
                        {
                            if(arrayToReturn[j-1] == 1)
                            {
                                arrayToReturn[j-1] = 0
                                break;
                            }

                        }
                        else
                        {
                            if(arrayToReturn[randNum + j] == 1)
                            {
                                arrayToReturn[randNum + j] = 0;
                                break;
                            }
                        }
                    }
                }
            }
        }
        console.log(arrayToReturn);
        //yay, we now have a placeholder mail queue!
    
        for(let i = 0; i < queueLength; i++)
        {
            if(arrayToReturn[i] == 0)
            {
                arrayToReturn[i] = this.chooseFakeMail();
            }
            else
            {
                arrayToReturn[i] = this.chooseRealMail();
            }
        }

        return [...arrayToReturn]; //returns a copy of the usedMailFakeArray
    }

    chooseFakeMail() //give an unused scam email, then moves that to the used mail 
    {
        if(this.unusedMailFake.length > 0) //check to make sure there's at least one element
        {
        }
        else //move all the elements from used array to unused array
        {
            this.unusedMailFake = [...this.usedMailFake];
            this.usedMailFake = [];
        }
        let randomToCheck = Math.floor(Math.random() * this.unusedMailFake.length);
        let randomMail = this.unusedMailFake.splice(randomToCheck, 1);
        this.usedMailFake.push(randomMail[0]);
        return randomMail[0];
    }
    chooseRealMail() //give an unused legitimate email, then moves that to the used mail
    {
        if(this.unusedMailReal.length > 0) //check to make sure there's at least one element
        {
        }
        else //move all the elements from used array to unused array
        {
            this.unusedMailReal = [...this.usedMailReal];
            this.usedMailReal = [];
                
        }
        let randomToCheck = Math.floor(Math.random() * this.unusedMailReal.length);
        let randomMail = this.unusedMailReal.splice(randomToCheck, 1);
        this.usedMailReal.push(randomMail[0]);
        return randomMail[0];
    }

    /*displayNewMail(mail) //the code that loads/unloads images, and sets up the new email.
    {
        this.load.image(mail.imagePath, mail.imagePath); //uses the URL as a key
        this.mailSprite.destroy();
        this.load.on(Phaser.Loader.Events.COMPLETE, () => 
        {
            this.mailSprite = this.add.sprite(0, 0, mail.imagePath).setOrigin(0,0);
        });
        this.load.start();
        
    }*/

    showNewMail(queue) //shows the current mail + side bar.
    {
        this.load.image(queue[0].imagePath, queue[0].imagePath); //uses the URL as the key
        this.load.on(Phaser.Loader.Events.COMPLETE, () => 
        {
            if(this.mailSprite != 0)
            {
                this.mailSprite.destroy();
            }
            this.mailSprite = this.add.sprite(0, 0, queue[0].imagePath).setOrigin(0,0);
            //this.nextButton = new Button(this, "button", 1000, 700, this.funct = function(){this.displayNewMail(this.chooseNewMail())});
        });
        this.load.start();
    }

    nextMailInQueue(queue) //helper function to be placed as an argument for a button
    {
        if(queue.length <= 1)
        {
            this.endRound();
        }
        else
        {
            queue.shift();
            this.showNewMail(queue);
        }
    }

    endRound() //ends the game when the email queue is empty
    {
        console.log("ended the game");
    }

    showReportMenu() //opens the report menu
    {
        this.reportMenu = this.add.sprite(600, 63, "Report_Menu").setOrigin(0,0);
        this.reportMenuCloseButton = new Button(this, "clearbutton_darken", 962, 67, this.hideReportMenu, []);
        this.reportMenuCloseButton.setHeight(33);
        this.reportMenuCloseButton.setWidth(33);

    }

    hideReportMenu() //closes the report menu and deletes the buttons/assets from the stage
    {
        this.reportMenu.destroy();
        this.reportMenuCloseButton._removeButton();
    }
}